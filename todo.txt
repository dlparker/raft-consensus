=================
Simplify plan:

1. Log changes
###### DONE
   1. Start Log with 1, as in docs, start term with 0, always incr on candidate
      PDF: page for state for all servers
   2. Add log record typing, "no-op" for new term, "client" for client command
      and include client serial number PDF: page 13, section 8
   3. Change log append api to support append as new index and
      insert at index, because leader can tell you to overwrite
###### DONE

2. Protocol
 ###### DONE
   1. Remove term start message
   2. Remove "log pull, replace it with regular append entries"
   4. Check for leader noting that it is out of date and resigning
   5. Rework candidate election timeout, currently goes back to follower,
      should instead restart election, but I think at least one test
      breaks on this change. Need to fix the test so that logic can
      match raft.pdf
   3. DID DIFFERENTLY Convert messages to dataclasses allow
      error in client command result
###### DONE

3. State logic changes:
###### DONE
   1. Remove rollback, as it is a dumb way to do log overwrite ###### DONE
   2. Find in PDF the logic on heartbeat when term does not match,
      fix it in follower and refernce PDF ###### DONE
   3. Add a flag and wait to ensure no new client command is processed
      while one is in flight. #### DONE
   4. Fix the way the client log records are created, get rid of
      the context thing. Just put the client record inside an envelope
      with return address info. ### DONE, but differently
###### DONE

   6. Is there an issue with tracking follower cursor when follower
       restarts? Do we have to detect it and reset? 
   7. Maybe need to run client command as a task with timeout? Currently
      it can hang server (ask me how I know)
   
==== Serializer Upgrades =====
#### DONE
1. Change serializer to an API and rename original. Have serialize
   to bytes and serialize to string.
2. Make a json serializer as a real example.
3. DONE, but differently, by adding a config class to server startup
  that specifies the serializer class
       Add serializer registry so that messages and log records can find
        the right serializer for app data by lookup.

==== Log Upgrades =====

1. Add serializer logic for log ops, with a dummy serializer for memory
2. Add persistent log (maybe sqlite?)
3. Make it async???? Do we really need this, or does the logic say
   it is okay to block on log writes? Certainly raft stuff can, but
   what about app? Does this choice limit choice of async/thread/mp for
   overall server architecture?


examine all abstract base classes to make sure they have the
correct __subclasshook__ method logic

add a setup step for comms api to install serializer class instead
of hard coding to original


---
Build something to collect and clear unhandled errors in server.py,
including a logging mechanism that is robust against errors, so
the errors go in an in-memory log and then into a disk log such
that the second call will not kill the process or result in a loop.
Maybe an "ErrorSink" class? 

Find all the state locations that can produce an unrecoverable
error and have them report the error to the state machine, which
will report it to the server, which will save it in unrecoverable.

Build an unrecoverable error mechanism that calls app.restart to
see if the server should die, restart, or whatever. Maybe a callback
in the base server? (Maybe need to rename "Server" class to something
like ServerCore?) Find all bad spots in the states and change the
exception clauses to call this method, execute stop on self and return.
---

LOOK AT:  https://typer.tiangolo.com/

############# DONE
Review and document new message times and ensure that they
actually improve things compared to the more limited set defined
in the raft paper. Do a side by side sequence diagram to identify
where my messages take the place of appendentries messages with
specific values and follower states.
############# DONE



###### DONE
Update the log api to have a call that commits each record it adds, cause
that is always done for log_pull. STUDY THE PROTOCOL, what happens when
leader has uncommitted record and follower does not, but follower was
not present when leader sent append?
###### DONE

##### DONE
Move the memory log, memory comms to dev_tools.
##### DONE

###### DONE
Remove rollback logic if possible once rejoin logic developed.
###### DONE


###### DONE
Examing voting logic in follower, shouldn't it explicitly look for
wrong term? Or is StateDiff property good enough? Comment in code.
###### DONE

##### DONE
See if the Pauser class used in some tests can be universal and in dev_tools
##### DONE



