
############# DONE
Review and document new message times and ensure that they
actually improve things compared to the more limited set defined
in the raft paper. Do a side by side sequence diagram to identify
where my messages take the place of appendentries messages with
specific values and follower states.
############# DONE


examine all abstract base classes to make sure they have the
correct __subclasshook__ method logic

add a setup step for comms api to install serializer class instead
of hard coding to original

clean up log api around storing pending response to client, the whole
context thing is a fudge, we should be more agressive about log
data format, probably adding context there.

---
Build something to collect and clear unhandled errors in server.py,
including a logging mechanism that is robust against errors, so
the errors go in an in-memory log and then into a disk log such
that the second call will not kill the process or result in a loop.
Maybe an "ErrorSink" class? 

Find all the state locations that can produce an unrecoverable
error and have them report the error to the state machine, which
will report it to the server, which will save it in unrecoverable.

Build an unrecoverable error mechanism that calls app.restart to
see if the server should die, restart, or whatever. Maybe a callback
in the base server? (Maybe need to rename "Server" class to something
like ServerCore?) Find all bad spots in the states and change the
exception clauses to call this method, execute stop on self and return.
---

###### DONE
Update the log api to have a call that commits each record it adds, cause
that is always done for log_pull. STUDY THE PROTOCOL, what happens when
leader has uncommitted record and follower does not, but follower was
not present when leader sent append?
###### DONE

Move the memory log, memory comms and udp comms to dev_tools.

###### DONE
Remove rollback logic if possible once rejoin logic developed.
###### DONE

Change serializer to an API and rename original

###### DONE
Examing voting logic in follower, shouldn't it explicitly look for
wrong term? Or is StateDiff property good enough? Comment in code.
###### DONE

See if the Pauser class used in some tests can be universal and in dev_tools

=================
Simplify plan:

1. Log changes
   1. Start Log with 1, as in docs, start term with 0, always incr on candidate
      PDF: page for state for all servers ###### DONE

   2. Add log record typing, "no-op" for new term, "client" for client command
      and include client serial number PDF: page 13, section 8
   3. Change log append api to support append as new index and
      insert at index, because leader can tell you to overwrite ###### DONE

2. Protocol
   1. Remove term start message ###### DONE
   2. Remove "log pull, replace it with regular append entries" ###### DONE
   3. Convert messages to dataclasses
   4. Check for leader noting that it is out of date and resigning ###### DONE

3. State logic changes:
   1. Remove rollback, as it is a dumb way to do log overwrite ###### DONE
   2. Find in PDF the logic on heartbeat when term does not match,
      fix it in follower and refernce PDF ###### DONE
   3. Add a set of queues to do client comms process, where
      incoming client command queues, something reads it and starts
      command processing sequence, then when the resulting log
      record is committed that goes into out queue. A flag indicates
      that we are in progress between the queue operations, so no
      new read can start. This serializes operations. 
   4. Fix the way the client log records are created, get rid of
      the context thing. Just put the client record inside an envelope
      with return address info.
   5. Make provision for client command to come from within server
      instead of from actual client, thus allowing consensus in servers.
      Prolly make some form of internal addressing scheme instead of real
      comm address. Can use some special type instead of tuple. Good
      place to test non-tuple address usage. Consider how this might
      also support a queue based mechanism where GRPC is used to put and
      pull from the queues. Client ops can put, then await pull. Server
      ops can put and return.
    6. Is there an issue with tracking follower cursor when follower
       restarts? Do we have to detect it and reset? 
     
   
==== Upgrades =====
1. Log
   3. Add serializer logic for log ops, with a dummy serializer for memory
   4. Make it async

