DONE! 1. Messaege classes update
   a. Also remove leaderCommit from vote.
   b. Consider removing the data stuff from the messages too, it is not requred except for
      append entries sequences
   c. Look at each one for simplifications and clarifications. Build short and long __rep__
      for each

DONE! 2. Condense comms and DSL into a single structure, something like "pilot".

2.b Add config read and write and config-to-and-from-json to hull. Think about defining
    and API for the hull (probably not since it needs stuff at init)
    
3. Make command call part of base state with appropriate response if not leader. Follower replies
   "redirect: uri", candiate response "retry". Build a test sequence for this.

4. Build test wrapper (maybe an implementation of "pilot"?) that supports message pausing based
   on patterns, e.g. after sending an apppend entries response. Have it also know how to
   perform simulated timer triggers

5. Change entries sent to proposed log record, so that things like config data can
   be destributed the same was as commands
   
10. Consider adding the state map logic or something like it so that "pilot" can receive
    callbacks to notify about state changes. Prolly simpler than the original. Maybe
    something that can be implemented in base_state or even hull.

# REVIEW
2. Message ops
   a. Add some means for the caller of the on_message function to tell the target how to send a response back,
      probably and async callable (awaitable then, I guess). Think about what else might allow the caller
      to just put this in the loop and ignore it if the comm mechanism is not call/response, and how it
      would best work if the comm mechanism IS rpc.

   b. Add mechanism to tell states (via hull) how to send messages that are not responses. Should use
       the same kind of opaque id stuff used in the protocol messages.
    
3. Clearify the support for writing uncommitted records to log, that is only done by the leader,
   and each record is committed once the majority concurrence is noted. Maybe just a little renaming
   and some comments.

4. Think about how to structure the "start raft logged write" process in such a way that the raft
   code can say "no, I am not leader, here is the leader id, send it to them".

5. Game a scenario where we use the raft log to just persist a reference to something stored elsewhere,
   see if that can make sense. This allows an alternative to building your own logAPI implementation
   so that raft records can be stored in app storage. Think about it especially in terms of how you'd
   do it in Dora, saving Dora log records locally and expecting remote nodes to save them too, then the
   append entries operation (on remotes) would want to try to sync with that state. Could it work
   where the Dora log record has not yet arrived? Maybe set up a periodic sweep that looks for
   raft claims in advance of local state and requests resend of Dora record? That might actually
   work for recovery of a follower after crash, but look for a complete edge case definition.

6. Need to make sure this line from the doc is true: "if one servers term is smaller than anothers
(on message) then it updates its term to the larger value"

7. Need to write up implications of recovery processing, i.e. that operations that were done at a server
   might be overwritten, so if you persist stuff based on the command execution there needs to be
   an undo operation (and this library needs to support it, which means follower needs to call undo
   steps on records that are being overwritten). Should explain how this can be handled by supplying
   a custom logAPI module so that raft log operations can be transactional with "real" state storage
   operations.

8, Change log api to support multiple record types, command, cluster_config, for sure maybe others.

9. Change command processor sequence to provide unsaved log record with message then save the result.
   Check raft.pdf to see if there is an implication that a restarted leader might have uncommitted
   records to apply, and if not then get rid of whole committed/not committed logic everywhere. Otherwise
   think about how to store them, maybe separate table so that there is no confusion about what the
   log actually looks like?

